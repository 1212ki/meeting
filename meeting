#!/usr/bin/env bash

# ====================================
# Meeting Recording Tool
# ====================================
# ä½¿ã„æ–¹:
#   meeting start "ä¼šè­°å" --å•†è«‡ [--hold|--no-hold]                - å•†è«‡ã®éŒ²éŸ³é–‹å§‹
#   meeting start "ä¼šè­°å" --ç¤¾å†… [--hold|--no-hold]                - ç¤¾å†…ä¼šè­°ã®éŒ²éŸ³é–‹å§‹
#   meeting start "ä¼šè­°å" --ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆ [--hold|--no-hold]       - ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆã®éŒ²éŸ³é–‹å§‹
#   meeting start "ä¼šè­°å" --å•†è«‡ --web [--hold|--no-hold]          - WEBå•†è«‡ã®éŒ²éŸ³é–‹å§‹
#   meeting start "ä¼šè­°å" --ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆ --side-business kondate-loop --web
#                                                    - å€‹äººäº‹æ¥­ã®WEBä¼šè­°ã‚’éŒ²éŸ³é–‹å§‹
#   meeting stop [--async]                            - éŒ²éŸ³åœæ­¢ â†’ æ–‡å­—èµ·ã“ã— â†’ è¦ç´„
#   meeting list                                      - éŒ²éŸ³ä¸€è¦§
#   meeting reprocess <transcript.txt> [--md <path>] [--replace]
#   meeting import <memo.md> [--ç¤¾å†…/--å•†è«‡/--ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆ/--side-business]
# ====================================

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
ROOT_DIR="$(cd "$SCRIPT_DIR/../.." && pwd)"
MEETINGS_DIR="$ROOT_DIR/knowledge/meetings"
AUDIO_DIR="$MEETINGS_DIR/_audio"
LOG_DIR="$MEETINGS_DIR/log"
REGULAR_MEETINGS_FILE="$SCRIPT_DIR/regular-meetings.tsv"
SLACK_ENV_FILE="$ROOT_DIR/tools/podcast-summarizer/.env"

PID_FILE="$AUDIO_DIR/.recording.pid"
INFO_FILE="$AUDIO_DIR/.recording.info"
AUDIO_BACKUP_FILE="$AUDIO_DIR/.audio_output_backup"
OUTPUT_WATCH_PID_FILE="$AUDIO_DIR/.output_watch.pid"

KEEP_AUDIO="${MEETING_KEEP_AUDIO:-0}"
SUMMARY_MIN_CHARS="${MEETING_SUMMARY_MIN_CHARS:-400}"
LOG_RETENTION_DAYS="${MEETING_LOG_RETENTION_DAYS:-14}"
RECORDING_HEALTH_CHECKS="${MEETING_RECORDING_HEALTH_CHECKS:-6}"
RECORDING_HEALTH_CHECKS_WEB="${MEETING_RECORDING_HEALTH_CHECKS_WEB:-14}"
RECORDING_HEALTH_INTERVAL="${MEETING_RECORDING_HEALTH_INTERVAL:-1}"
RECORDING_MIN_BYTES="${MEETING_RECORDING_MIN_BYTES:-1024}"
WHISPER_MODEL="${MEETING_WHISPER_MODEL:-small}"
WHISPER_LANG="${MEETING_WHISPER_LANGUAGE:-Japanese}"
WHISPER_BIN="${MEETING_WHISPER_BIN:-${WHISPER_PATH:-}}"

MEETING_AUDIO_EARPHONE="${MEETING_AUDIO_EARPHONE:-ä¼šè­°ç”¨ã‚¤ãƒ¤ãƒ›ãƒ³}"
MEETING_AUDIO_SPEAKER="${MEETING_AUDIO_SPEAKER:-ä¼šè­°ç”¨ã‚¹ãƒ”ãƒ¼ã‚«ãƒ¼}"
MEETING_WEB_OUTPUT_DEVICE="${MEETING_WEB_OUTPUT_DEVICE:-auto}"
MEETING_WEB_OUTPUT_AUTO_SWITCH="${MEETING_WEB_OUTPUT_AUTO_SWITCH:-1}"
MEETING_WEB_INPUT_DEVICE="${MEETING_WEB_INPUT_DEVICE:-BlackHole 2ch}"
MEETING_WEB_MIC_DEVICE="${MEETING_WEB_MIC_DEVICE:-}"
MEETING_WEB_MIC_DEVICE_EARPHONE="${MEETING_WEB_MIC_DEVICE_EARPHONE:-}"
MEETING_WEB_INPUT_GAIN_BLACKHOLE="${MEETING_WEB_INPUT_GAIN_BLACKHOLE:-1.0}"
MEETING_WEB_INPUT_GAIN_MIC="${MEETING_WEB_INPUT_GAIN_MIC:-1.0}"
MEETING_WEB_AUTO_LEVEL="${MEETING_WEB_AUTO_LEVEL:-1}"
MEETING_WEB_LIMITER="${MEETING_WEB_LIMITER:-1}"
MEETING_WEB_LIMITER_FILTER="${MEETING_WEB_LIMITER_FILTER:-alimiter=limit=0.95:attack=5:release=50}"

MEETING_STORAGE_MODE="${MEETING_STORAGE_MODE:-auto}"
MEETING_AUTO_STOP="${MEETING_AUTO_STOP:-1}"
MEETING_START_HOLD_MODE="${MEETING_START_HOLD_MODE:-auto}"
MEETING_SLACK_ASYNC="${MEETING_SLACK_ASYNC:-1}"

# è‰²ä»˜ã‘
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

log_message() {
    local level="$1"
    local message="$2"
    local timestamp
    timestamp="$(date '+%Y-%m-%d %H:%M:%S')"
    printf '[%s] [%s] %s\n' "$timestamp" "$level" "$message" >> "$LOG_DIR/meeting-$(date '+%Y-%m-%d').log"
}

rotate_logs() {
    if [ -d "$LOG_DIR" ]; then
        find "$LOG_DIR" -type f -name 'meeting-*.log' -mtime "+$LOG_RETENTION_DAYS" -delete 2>/dev/null || true
    fi
    if [ -d "$AUDIO_DIR" ]; then
        find "$AUDIO_DIR" -type f -name '*.ffmpeg.log' -mtime "+$LOG_RETENTION_DAYS" -delete 2>/dev/null || true
        find "$AUDIO_DIR" -type f -name '*.wav' -size 0 -mtime "+$LOG_RETENTION_DAYS" -delete 2>/dev/null || true
    fi
}

ensure_dirs() {
    mkdir -p "$MEETINGS_DIR" "$AUDIO_DIR" "$LOG_DIR"
    mkdir -p "$MEETINGS_DIR/ç¤¾å†…" "$MEETINGS_DIR/å•†è«‡" "$MEETINGS_DIR/private"
    mkdir -p "$MEETINGS_DIR/side-business" "$MEETINGS_DIR/activities" "$MEETINGS_DIR/thoughts" "$MEETINGS_DIR/life"
}

cleanup_recording_state() {
    rm -f "$PID_FILE" "$INFO_FILE"
}

is_process_running() {
    local pid="$1"
    [ -n "$pid" ] && ps -p "$pid" >/dev/null 2>&1
}

resolve_hold_mode() {
    local explicit="$1"
    if [ "$explicit" = "1" ] || [ "$explicit" = "0" ]; then
        printf '%s' "$explicit"
        return 0
    fi

    case "$MEETING_START_HOLD_MODE" in
        always|ALWAYS|1|true|TRUE|yes|YES)
            printf '1'
            ;;
        never|NEVER|0|false|FALSE|no|NO)
            printf '0'
            ;;
        auto|AUTO|"")
            if [ -t 1 ]; then
                printf '0'
            else
                printf '1'
            fi
            ;;
        *)
            if [ -t 1 ]; then
                printf '0'
            else
                printf '1'
            fi
            ;;
    esac
}

get_file_size_bytes() {
    local file="$1"
    if [ ! -f "$file" ]; then
        printf '0'
        return 0
    fi
    local bytes
    bytes=$(wc -c < "$file" 2>/dev/null | tr -d '[:space:]')
    if [ -z "$bytes" ]; then
        bytes="0"
    fi
    printf '%s' "$bytes"
}

show_ffmpeg_log_tail() {
    local ffmpeg_log="$1"
    if [ -z "$ffmpeg_log" ] || [ ! -f "$ffmpeg_log" ]; then
        return 0
    fi
    echo -e "${YELLOW}ffmpegãƒ­ã‚°ï¼ˆæœ«å°¾ï¼‰: ${ffmpeg_log}${NC}"
    tail -n 20 "$ffmpeg_log" | sed 's/^/  /'
}

stop_recording_process() {
    local pid="$1"
    if ! is_process_running "$pid"; then
        return 0
    fi
    kill -INT "$pid" 2>/dev/null || true
    local wait_count=0
    while [ "$wait_count" -lt 5 ]; do
        if ! is_process_running "$pid"; then
            return 0
        fi
        sleep 1
        wait_count=$((wait_count + 1))
    done
    if is_process_running "$pid"; then
        kill -9 "$pid" 2>/dev/null || true
    fi
}

wait_for_recording_data() {
    local pid="$1"
    local audio_file="$2"
    local mode="${3:-}"
    local checks="$RECORDING_HEALTH_CHECKS"
    if [ "$mode" = "web" ]; then
        checks="$RECORDING_HEALTH_CHECKS_WEB"
    fi
    local interval="$RECORDING_HEALTH_INTERVAL"
    local min_bytes="$RECORDING_MIN_BYTES"
    local i=0

    while [ "$i" -lt "$checks" ]; do
        if ! is_process_running "$pid"; then
            return 1
        fi
        local bytes
        bytes="$(get_file_size_bytes "$audio_file")"
        if [ "$bytes" -ge "$min_bytes" ]; then
            return 0
        fi
        sleep "$interval"
        i=$((i + 1))
    done

    return 1
}

show_help() {
    cat << EOF
Meeting Recording Tool

ä½¿ã„æ–¹:
  meeting start "ä¼šè­°å" --å•†è«‡ [--hold|--no-hold]        å•†è«‡ã®éŒ²éŸ³é–‹å§‹
  meeting start "ä¼šè­°å" --ç¤¾å†… [--hold|--no-hold]        ç¤¾å†…ä¼šè­°ã®éŒ²éŸ³é–‹å§‹
  meeting start "ä¼šè­°å" --ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆ [--hold|--no-hold]        ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆã®éŒ²éŸ³é–‹å§‹
  meeting start "ä¼šè­°å" --å•†è«‡ --web [--hold|--no-hold]  WEBå•†è«‡ã®éŒ²éŸ³
  meeting start "ä¼šè­°å" --ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆ --side-business kondate-loop --web
                                      å€‹äººäº‹æ¥­ã®WEBä¼šè­°ã‚’éŒ²éŸ³
  meeting stop [--async]              éŒ²éŸ³åœæ­¢ â†’ æ–‡å­—èµ·ã“ã—ï¼ˆ.txtç”Ÿæˆï¼‰
  meeting list                         éŒ²éŸ³ä¸€è¦§ã‚’è¡¨ç¤º
  meeting reprocess <transcript.txt> [--md <path>] [--replace]
  meeting import <memo.md>

ä¾‹:
  meeting start "Aç¤¾ãƒ—ãƒ¬ã‚¼ãƒ³" --å•†è«‡
  meeting start "é€±æ¬¡å®šä¾‹" --ç¤¾å†… --hold
  meeting start "Bç¤¾Zoom" --å•†è«‡ --web
  meeting stop

ä¿å­˜å…ˆ:
  å•†è«‡: $MEETINGS_DIR/å•†è«‡/
  ç¤¾å†…: $MEETINGS_DIR/ç¤¾å†…/
  ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆ: $MEETINGS_DIR/private/
  å€‹äººäº‹æ¥­: $MEETINGS_DIR/side-business/<ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆå>/
  æ´»å‹•: $MEETINGS_DIR/activities/
  thoughts: $MEETINGS_DIR/thoughts/
  life: $MEETINGS_DIR/life/
  æœªåˆ†é¡: $MEETINGS_DIR/
EOF
}

load_slack_env() {
    if [ -f "$SLACK_ENV_FILE" ]; then
        set -a
        # shellcheck disable=SC1090
        . "$SLACK_ENV_FILE"
        set +a
    fi
}

send_slack_message() {
    local message="$1"
    local webhook="${MEETING_SLACK_WEBHOOK_URL:-${SLACK_WEBHOOK_URL:-}}"

    if [ -z "$webhook" ]; then
        return 0
    fi
    if ! command -v python3 >/dev/null 2>&1; then
        return 0
    fi

    python3 - "$webhook" "$message" << 'PY'
import json
import sys
import urllib.request

webhook = sys.argv[1]
text = sys.argv[2]

payload = {"text": text}
data = json.dumps(payload).encode("utf-8")
req = urllib.request.Request(webhook, data=data, headers={"Content-Type": "application/json"})
try:
    with urllib.request.urlopen(req, timeout=10) as res:
        res.read()
except Exception:
    pass
PY
}

send_start_notification() {
    local title="$1"
    local env_label="$2"
    local message
    message="éŒ²éŸ³ã‚’é–‹å§‹ã—ã¾ã—ãŸ-ä¼šè­°å:${title} ${env_label}"
    load_slack_env
    if [ "$MEETING_SLACK_ASYNC" = "1" ]; then
        send_slack_message "$message" >/dev/null 2>&1 &
    else
        send_slack_message "$message" >/dev/null 2>&1
    fi
}

send_stop_notification() {
    local duration="$1"
    local message
    message="éŒ²éŸ³ã‚’çµ‚äº†ã—ã¾ã—ãŸ-${duration} æ–‡å­—èµ·ã“ã—ä¸­..."
    load_slack_env
    if [ "$MEETING_SLACK_ASYNC" = "1" ]; then
        send_slack_message "$message" >/dev/null 2>&1 &
    else
        send_slack_message "$message" >/dev/null 2>&1
    fi
}

send_complete_notification() {
    local md_path="$1"
    local summary="$2"
    local decisions="$3"
    local todos="$4"

    local message
    message=$(printf 'è­°äº‹éŒ²ã‚’ä½œæˆã—ã¾ã—ãŸ\nãƒ‘ã‚¹: %s' "$md_path")
    if [ -n "$summary" ] && [[ "$summary" != *"æœªç”Ÿæˆ"* ]]; then
        message+=$(printf '\nè¦ç‚¹: %s' "$summary")
    fi
    if [ -n "$decisions" ] && [[ "$decisions" != *"æœªæŠ½å‡º"* ]]; then
        message+=$(printf '\næ±ºå®šäº‹é …: %s' "$decisions")
    fi
    if [ -n "$todos" ] && [[ "$todos" != *"æœªæŠ½å‡º"* ]]; then
        message+=$(printf '\nTODO: %s' "$todos")
    fi

    load_slack_env
    if [ "$MEETING_SLACK_ASYNC" = "1" ]; then
        send_slack_message "$message" >/dev/null 2>&1 &
    else
        send_slack_message "$message" >/dev/null 2>&1
    fi
}

check_dependencies() {
    if ! command -v ffmpeg >/dev/null 2>&1; then
        echo -e "${RED}ã‚¨ãƒ©ãƒ¼: ffmpeg ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“${NC}"
        echo "ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«: brew install ffmpeg"
        exit 1
    fi
}

get_default_audio_device() {
    local device=""
    if command -v SwitchAudioSource >/dev/null 2>&1; then
        device=$(SwitchAudioSource -t input -c 2>/dev/null || true)
    fi

    if [ -z "$device" ]; then
        device=$(system_profiler SPAudioDataType 2>/dev/null | awk '
            /^[[:space:]]+[^:]+:$/ {
                name=$0
                sub(/^[[:space:]]+/, "", name)
                sub(/:$/, "", name)
            }
            /Default Input Device: Yes/ {
                print name
                exit
            }
        ')
    fi

    printf '%s' "$device"
}

get_default_output_device() {
    local device=""
    if command -v SwitchAudioSource >/dev/null 2>&1; then
        device=$(SwitchAudioSource -t output -c 2>/dev/null || true)
    fi

    if [ -z "$device" ]; then
        device=$(system_profiler SPAudioDataType 2>/dev/null | awk '
            /^[[:space:]]+[^:]+:$/ {
                name=$0
                sub(/^[[:space:]]+/, "", name)
                sub(/:$/, "", name)
            }
            /Default Output Device: Yes/ {
                print name
                exit
            }
        ')
    fi

    printf '%s' "$device"
}

get_available_output_devices() {
    if command -v SwitchAudioSource >/dev/null 2>&1; then
        SwitchAudioSource -a -t output 2>/dev/null || true
    fi
}

get_builtin_speaker_device() {
    local devices
    devices="$(get_available_output_devices)"
    if [ -z "$devices" ]; then
        return 1
    fi

    local match
    match="$(printf '%s\n' "$devices" | grep -E 'MacBook.*(ã‚¹ãƒ”ãƒ¼ã‚«ãƒ¼|Speakers)|å†…è”µã‚¹ãƒ”ãƒ¼ã‚«ãƒ¼|Internal Speakers' | head -n 1)"
    if [ -n "$match" ]; then
        printf '%s' "$match"
        return 0
    fi

    return 1
}

is_earphone_connected() {
    local devices
    devices="$(get_available_output_devices)"
    if [ -n "$devices" ]; then
        local filtered
        filtered="$(printf '%s\n' "$devices" | grep -v "^ä¼šè­°ç”¨" || true)"
        if printf '%s\n' "$filtered" | grep -qiE 'ãƒ˜ãƒƒãƒ‰ãƒ•ã‚©ãƒ³|ã‚¤ãƒ¤ãƒ›ãƒ³|AirPods|Headphone|Earphone'; then
            return 0
        fi
        return 1
    fi

    local current
    current="$(get_default_output_device)"
    if printf '%s' "$current" | grep -qiE 'ãƒ˜ãƒƒãƒ‰ãƒ•ã‚©ãƒ³|ã‚¤ãƒ¤ãƒ›ãƒ³|AirPods|Headphone|Earphone'; then
        return 0
    fi
    return 1
}

audio_device_exists() {
    local target="$1"
    if [ -z "$target" ]; then
        return 1
    fi
    if command -v SwitchAudioSource >/dev/null 2>&1; then
        SwitchAudioSource -a 2>/dev/null | grep -qxF "$target"
        return $?
    fi
    system_profiler SPAudioDataType 2>/dev/null | awk -v target="$target" '
        /^[[:space:]]+[^:]+:$/ {
            name=$0
            sub(/^[[:space:]]+/, "", name)
            sub(/:$/, "", name)
            if (name == target) {
                found=1
            }
        }
        END { exit(found ? 0 : 1) }
    '
}

resolve_restore_output_device() {
    local devices
    local match

    if is_earphone_connected; then
        devices="$(get_available_output_devices)"
        if [ -n "$devices" ]; then
            match="$(printf '%s\n' "$devices" | grep -v "^ä¼šè­°ç”¨" | grep -iE 'ãƒ˜ãƒƒãƒ‰ãƒ•ã‚©ãƒ³|ã‚¤ãƒ¤ãƒ›ãƒ³|AirPods|Headphone|Earphone' | head -n 1)"
            if [ -n "$match" ]; then
                printf '%s' "$match"
                return 0
            fi
        fi
    fi

    local builtin
    builtin="$(get_builtin_speaker_device)"
    if [ -n "$builtin" ]; then
        printf '%s' "$builtin"
        return 0
    fi

    printf '%s' "$(get_default_output_device)"
}

resolve_web_output_device() {
    local requested="$MEETING_WEB_OUTPUT_DEVICE"

    if [ -n "$requested" ] && [ "$requested" != "auto" ]; then
        printf '%s' "$requested"
        return 0
    fi

    if is_earphone_connected && audio_device_exists "$MEETING_AUDIO_EARPHONE"; then
        printf '%s' "$MEETING_AUDIO_EARPHONE"
        return 0
    fi

    if audio_device_exists "$MEETING_AUDIO_SPEAKER"; then
        printf '%s' "$MEETING_AUDIO_SPEAKER"
        return 0
    fi

    printf '%s' "$(get_default_output_device)"
}

switch_to_meeting_output() {
    if [ "$MEETING_WEB_OUTPUT_AUTO_SWITCH" != "1" ]; then
        return 0
    fi
    if ! command -v SwitchAudioSource >/dev/null 2>&1; then
        echo -e "${YELLOW}è­¦å‘Š: SwitchAudioSource ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ï¼ˆå‡ºåŠ›è‡ªå‹•åˆ‡æ›¿ãŒç„¡åŠ¹ï¼‰${NC}"
        return 0
    fi

    local current
    current="$(get_default_output_device)"
    local target
    target="$(resolve_web_output_device)"

    if [ -z "$target" ]; then
        return 0
    fi

    if [ "$current" = "$target" ]; then
        return 0
    fi

    if [ -n "$current" ]; then
        printf '%s' "$current" > "$AUDIO_BACKUP_FILE"
    fi

    SwitchAudioSource -s "$target" -t output >/dev/null 2>&1 || true

    local after
    after="$(get_default_output_device)"
    if [ "$after" != "$target" ]; then
        echo -e "${YELLOW}è­¦å‘Š: å‡ºåŠ›ãŒã€Œ$targetã€ã«ãªã£ã¦ã„ã¾ã›ã‚“ï¼ˆç¾åœ¨: ${after:-ä¸æ˜}ï¼‰${NC}"
    fi
}

start_output_watcher() {
    local interval="${MEETING_WEB_OUTPUT_POLL_INTERVAL:-5}"
    if [ "$MEETING_WEB_OUTPUT_AUTO_SWITCH" != "1" ]; then
        return 0
    fi
    if ! command -v SwitchAudioSource >/dev/null 2>&1; then
        return 0
    fi

    stop_output_watcher

    nohup bash -c '
        earphone='"'$MEETING_AUDIO_EARPHONE'"'
        speaker='"'$MEETING_AUDIO_SPEAKER'"'
        interval='"$interval"'
        while true; do
            has_earphone="$(SwitchAudioSource -a -t output 2>/dev/null | grep -v "^ä¼šè­°ç”¨" | grep -iE "ãƒ˜ãƒƒãƒ‰ãƒ•ã‚©ãƒ³|ã‚¤ãƒ¤ãƒ›ãƒ³|AirPods|Headphone|Earphone" | head -n 1)"
            if [ -n "$has_earphone" ]; then
                want="$earphone"
            else
                want="$speaker"
            fi
            current="$(SwitchAudioSource -t output -c 2>/dev/null)"
            if [ -n "$want" ] && [ "$current" != "$want" ]; then
                SwitchAudioSource -s "$want" -t output >/dev/null 2>/dev/null
            fi
            sleep "$interval"
        done
    ' >/dev/null 2>&1 &

    echo $! > "$OUTPUT_WATCH_PID_FILE"
}

sync_multisoundchanger() {
    if ! pgrep -f MultiSoundChanger >/dev/null 2>&1; then
        return 0
    fi
    killall MultiSoundChanger 2>/dev/null || true
    sleep 0.5
    open -a MultiSoundChanger 2>/dev/null || true
    sleep 0.5
}

stop_output_watcher() {
    if [ -f "$OUTPUT_WATCH_PID_FILE" ]; then
        local watch_pid
        watch_pid=$(cat "$OUTPUT_WATCH_PID_FILE" 2>/dev/null || true)
        rm -f "$OUTPUT_WATCH_PID_FILE"
        if [ -n "$watch_pid" ]; then
            kill "$watch_pid" 2>/dev/null || true
            local wait_count=0
            while is_process_running "$watch_pid" && [ "$wait_count" -lt 5 ]; do
                sleep 0.2
                wait_count=$((wait_count + 1))
            done
        fi
    fi
}

restore_audio_output() {
    if ! command -v SwitchAudioSource >/dev/null 2>&1; then
        return 0
    fi

    if [ -f "$AUDIO_BACKUP_FILE" ]; then
        local original
        original="$(cat "$AUDIO_BACKUP_FILE" 2>/dev/null || true)"
        if [ -n "$original" ]; then
            SwitchAudioSource -s "$original" -t output >/dev/null 2>&1 || true
            sleep 1
            local after
            after="$(get_default_output_device)"
            if [ "$after" = "$original" ]; then
                rm -f "$AUDIO_BACKUP_FILE"
                echo -e "${GREEN}å‡ºåŠ›ãƒ‡ãƒã‚¤ã‚¹ã‚’å¾©å…ƒã—ã¾ã—ãŸ: $original${NC}"
                return 0
            fi
            SwitchAudioSource -s "$original" -t output >/dev/null 2>&1 || true
            after="$(get_default_output_device)"
            if [ "$after" = "$original" ]; then
                rm -f "$AUDIO_BACKUP_FILE"
                echo -e "${GREEN}å‡ºåŠ›ãƒ‡ãƒã‚¤ã‚¹ã‚’å¾©å…ƒã—ã¾ã—ãŸ: $original${NC}"
                return 0
            fi
            echo -e "${YELLOW}è­¦å‘Š: å‡ºåŠ›å¾©å…ƒã«å¤±æ•—ã—ã¾ã—ãŸï¼ˆç¾åœ¨: ${after:-ä¸æ˜}ï¼‰${NC}"
            echo -e "${YELLOW}æ‰‹å‹•å¾©å…ƒã™ã‚‹å ´åˆ: SwitchAudioSource -s \"$original\" -t output${NC}"
        fi
    fi

    local fallback
    fallback="$(resolve_restore_output_device)"
    if [ -n "$fallback" ]; then
        SwitchAudioSource -s "$fallback" -t output >/dev/null 2>&1 || true
        sleep 1
        local after
        after="$(get_default_output_device)"
        if [ "$after" = "$fallback" ]; then
            rm -f "$AUDIO_BACKUP_FILE"
            echo -e "${GREEN}å‡ºåŠ›ãƒ‡ãƒã‚¤ã‚¹ã‚’å¾©å…ƒã—ã¾ã—ãŸ: $fallback${NC}"
            return 0
        fi
        echo -e "${YELLOW}è­¦å‘Š: å‡ºåŠ›å¾©å…ƒã«å¤±æ•—ã—ã¾ã—ãŸï¼ˆç¾åœ¨: ${after:-ä¸æ˜}ï¼‰${NC}"
    fi
}

warn_multisoundchanger() {
    if [ -d "/Applications/MultiSoundChanger.app" ]; then
        if ! pgrep -f MultiSoundChanger >/dev/null 2>&1; then
            echo -e "${YELLOW}è­¦å‘Š: MultiSoundChanger ãŒèµ·å‹•ã—ã¦ã„ã¾ã›ã‚“ï¼ˆVolã‚­ãƒ¼èª¿æ•´ãŒåŠ¹ã‹ãªã„å¯èƒ½æ€§ï¼‰${NC}"
        fi
    else
        echo -e "${YELLOW}è­¦å‘Š: MultiSoundChanger ãŒæœªå°å…¥ã§ã™ï¼ˆVolã‚­ãƒ¼èª¿æ•´ãŒåŠ¹ã‹ãªã„å¯èƒ½æ€§ï¼‰${NC}"
    fi
}

list_avfoundation_audio_devices() {
    ffmpeg -f avfoundation -list_devices true -i "" 2>&1 | awk '
        /AVFoundation audio devices/ {flag=1; next}
        /AVFoundation video devices/ {flag=0}
        flag && match($0, /\[[0-9]+\]/) {print}
    '
}

first_avfoundation_audio_index() {
    local devices="$1"
    printf '%s\n' "$devices" | sed -nE 's/.*\[([0-9]+)\].*/\1/p' | head -n 1
}

resolve_avfoundation_index() {
    local device_name="$1"
    local devices="${2:-}"
    if [ -z "$device_name" ]; then
        return 1
    fi

    if [ -z "$devices" ]; then
        devices="$(list_avfoundation_audio_devices)"
    fi

    local line
    while IFS= read -r line; do
        local index
        local name
        index=$(printf '%s' "$line" | sed -E 's/.*\[([0-9]+)\].*/\1/')
        name=$(printf '%s' "$line" | sed -E 's/.*\[[0-9]+\][[:space:]]*//')
        if [ "$name" = "$device_name" ]; then
            printf '%s' "$index"
            return 0
        fi
    done <<< "$devices"

    return 1
}

resolve_input_device_name() {
    local fallback
    fallback="$(get_default_audio_device)"

    if [ -n "$MEETING_WEB_MIC_DEVICE_EARPHONE" ] && is_earphone_connected; then
        printf '%s' "$MEETING_WEB_MIC_DEVICE_EARPHONE"
        return 0
    fi

    if [ -n "$MEETING_WEB_MIC_DEVICE" ]; then
        printf '%s' "$MEETING_WEB_MIC_DEVICE"
        return 0
    fi

    printf '%s' "$fallback"
}

resolve_whisper_command() {
    if [ -n "$WHISPER_BIN" ] && [ -x "$WHISPER_BIN" ]; then
        printf '%s' "$WHISPER_BIN"
        return 0
    fi
    if command -v whisper >/dev/null 2>&1; then
        command -v whisper
        return 0
    fi
    printf '%s' "python3 -m whisper"
}

run_whisper() {
    local audio_file="$1"
    local output_dir="$2"

    local whisper_cmd
    whisper_cmd="$(resolve_whisper_command)"

    if [ -z "$whisper_cmd" ]; then
        echo -e "${RED}ã‚¨ãƒ©ãƒ¼: whisper ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“${NC}"
        echo "ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«: python3 -m pip install openai-whisper"
        return 1
    fi

    # shellcheck disable=SC2086
    $whisper_cmd "$audio_file" \
        --language "$WHISPER_LANG" \
        --model "$WHISPER_MODEL" \
        --output_format txt \
        --output_dir "$output_dir" \
        2>/dev/null
}

trim_text() {
    printf '%s' "$1" | sed -E 's/^[[:space:]]+//; s/[[:space:]]+$//'
}

strip_date_prefix() {
    printf '%s' "$1" | sed -E 's/^[0-9]{4}[-\/]?[0-9]{2}[-\/]?[0-9]{2}[_ -]*//g'
}

strip_meet_suffix() {
    printf '%s' "$1" | sed -E 's/[[:space:]]*[-â€“][[:space:]]*(Google Meet|Meet)$//'
}

strip_zoom_suffix() {
    printf '%s' "$1" | sed -E 's/[[:space:]]*[-â€“][[:space:]]*Zoom( Meeting)?$//'
}

sanitize_filename() {
    local name="$1"
    name="${name//\//_}"
    name="${name//\\/_}"
    name="${name//:/_}"
    name="${name//|/_}"
    name="${name//\"/}"
    name="${name//\'/}"
    name="${name//\?/_}"
    name="${name//\*/_}"
    name=$(printf '%s' "$name" | sed -E 's/[[:space:]]+/_/g; s/^_+//; s/_+$//')
    printf '%s' "$name"
}

normalize_title() {
    local title
    title="$(trim_text "$1")"
    title="$(strip_date_prefix "$title")"
    title="$(strip_meet_suffix "$title")"
    title="$(strip_zoom_suffix "$title")"
    trim_text "$title"
}

normalize_key() {
    printf '%s' "$1" | tr '[:upper:]' '[:lower:]' | sed -E 's/^[[:space:]]+//; s/[[:space:]]+$//'
}

match_regular_meeting() {
    local title="$1"
    local normalized
    normalized="$(normalize_key "$title")"

    if [ ! -f "$REGULAR_MEETINGS_FILE" ]; then
        return 1
    fi

    while IFS='|' read -r canonical aliases; do
        [ -z "$canonical" ] && continue
        case "$canonical" in
            \#*) continue ;;
        esac
        local canon_norm
        canon_norm="$(normalize_key "$canonical")"
        if [ "$normalized" = "$canon_norm" ]; then
            printf '%s' "$canonical"
            return 0
        fi
        IFS=',' read -r -a alias_list <<< "${aliases:-}"
        for alias in "${alias_list[@]}"; do
            local alias_norm
            alias_norm="$(normalize_key "$alias")"
            if [ -n "$alias_norm" ] && [ "$normalized" = "$alias_norm" ]; then
                printf '%s' "$canonical"
                return 0
            fi
        done
    done < "$REGULAR_MEETINGS_FILE"

    return 1
}

resolve_output_dir() {
    local category="$1"
    local storage_area="$2"
    local project_name="$3"

    if [ "$storage_area" = "side-business" ]; then
        local project="${project_name:-_general}"
        printf '%s' "$MEETINGS_DIR/side-business/$project"
        return 0
    fi
    if [ "$storage_area" = "activity" ]; then
        printf '%s' "$MEETINGS_DIR/activities"
        return 0
    fi
    if [ "$storage_area" = "thoughts" ]; then
        printf '%s' "$MEETINGS_DIR/thoughts"
        return 0
    fi
    if [ "$storage_area" = "life" ]; then
        printf '%s' "$MEETINGS_DIR/life"
        return 0
    fi
    if [ "$storage_area" = "private" ]; then
        printf '%s' "$MEETINGS_DIR/private"
        return 0
    fi

    if [ -n "$category" ]; then
        printf '%s' "$MEETINGS_DIR/$category"
        return 0
    fi

    printf '%s' "$MEETINGS_DIR"
}

resolve_env_label() {
    local web_mode="$1"
    local platform="$2"
    if [ -z "$web_mode" ]; then
        printf '%s' "å¯¾é¢"
        return 0
    fi

    case "$platform" in
        zoom|Zoom) printf '%s' "Zoom" ;;
        meet|Meet) printf '%s' "Meet" ;;
        teams|Teams) printf '%s' "Teams" ;;
        *) printf '%s' "Web" ;;
    esac
}

run_llm_prompt() {
    local prompt="$1"
    local output=""

    if command -v codex >/dev/null 2>&1; then
        local tmpfile
        tmpfile=$(mktemp)
        printf '%s' "$prompt" | codex exec -o "$tmpfile" - >/dev/null 2>&1 || true
        if [ -f "$tmpfile" ]; then
            output=$(cat "$tmpfile")
            rm -f "$tmpfile"
        fi
    elif command -v claude >/dev/null 2>&1; then
        output=$(printf '%s' "$prompt" | claude -p --output-format text 2>/dev/null || true)
    fi

    printf '%s' "$output"
}

extract_summary_json() {
    local excerpt="$1"
    local prompt
    prompt=$(cat << 'EOF'
ã‚ãªãŸã¯è­°äº‹éŒ²ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆã§ã™ã€‚ä»¥ä¸‹ã®æ–‡å­—èµ·ã“ã—ã‹ã‚‰è¦ç‚¹ã‚’æŠ½å‡ºã—ã€JSONã®ã¿ã§è¿”ã—ã¦ãã ã•ã„ã€‚

è¦ä»¶:
- summary: 3ã€œ5è¡Œã®è¦ç‚¹ã‚µãƒãƒªãƒ¼
- decisions: æ±ºå®šäº‹é …ã®ç®‡æ¡æ›¸ãï¼ˆæœ€å¤§5ä»¶ï¼‰
- todos: æŒã¡å¸°ã‚Šã‚¿ã‚¹ã‚¯ã®ç®‡æ¡æ›¸ãï¼ˆæœ€å¤§5ä»¶ï¼‰
- title_hint: ä¼šè­°åã®è£œåŠ©ï¼ˆçŸ­ã„åè©å¥ã€ä»»æ„ï¼‰

å‡ºåŠ›å½¢å¼(JSONã®ã¿):
{"summary": ["..."], "decisions": ["..."], "todos": ["..."], "title_hint": "..."}

æ–‡å­—èµ·ã“ã—:
EOF
)
    prompt+="$excerpt"
    run_llm_prompt "$prompt"
}

parse_summary_json() {
    python3 -c "$(cat << 'PY'
import json
import sys
import re

raw = sys.stdin.read()
def load_json(payload: str):
    try:
        return json.loads(payload)
    except Exception:
        return None

data = load_json(raw)
if data is None:
    fenced = re.search(r"```(?:json)?\\s*([\\s\\S]*?)```", raw)
    if fenced:
        data = load_json(fenced.group(1))
if data is None:
    for match in re.findall(r"{[\\s\\S]*?}", raw):
        data = load_json(match)
        if data is not None:
            break
if data is None:
    print("\x1f\x1f\x1f")
    sys.exit(0)

summary = data.get("summary") or []
if isinstance(summary, str):
    summary = [summary]
summary = [s.strip() for s in summary if str(s).strip()]

Dec = data.get("decisions") or []
if isinstance(Dec, str):
    Dec = [Dec]
Dec = [d.strip() for d in Dec if str(d).strip()]

todos = data.get("todos") or []
if isinstance(todos, str):
    todos = [todos]
Todos = [t.strip() for t in todos if str(t).strip()]

Title = str(data.get("title_hint") or "").strip()

field_sep = "\x1f"
line_sep = "\x1e"

def join_lines(items):
    return line_sep.join(items)

print(field_sep.join([
    join_lines(summary),
    join_lines(Dec),
    join_lines(Todos),
    Title.replace("\\n", line_sep),
]))
PY
)"
}

decode_summary_field() {
    printf '%s' "$1" | tr '\036' '\n'
}

extract_metadata_json() {
    local excerpt="$1"
    local prompt
    prompt=$(cat << 'EOF'
ä»¥ä¸‹ã®æ–‡å­—èµ·ã“ã—ã‹ã‚‰ä¼šè­°ã®ç¨®åˆ¥ã‚’æ¨å®šã—ã€JSONã®ã¿ã§è¿”ã—ã¦ãã ã•ã„ã€‚

è¦ä»¶:
- category: å•†è«‡/ç¤¾å†…/ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆ/ä¸æ˜ ã®ã„ãšã‚Œã‹
- storage_area: work/private/side-business/activity/thoughts/life/auto ã®ã„ãšã‚Œã‹
- project: side-businessã®å ´åˆã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆåï¼ˆä¸æ˜ãªã‚‰ç©ºæ–‡å­—ï¼‰
- counterparty: ç›¸æ‰‹å…ˆ/ä¼šè­°åã®è£œåŠ©ï¼ˆä¸æ˜ãªã‚‰ç©ºæ–‡å­—ï¼‰

å‡ºåŠ›å½¢å¼(JSONã®ã¿):
{"category": "ç¤¾å†…", "storage_area": "work", "project": "", "counterparty": ""}

æ–‡å­—èµ·ã“ã—:
EOF
)
    prompt+="$excerpt"
    run_llm_prompt "$prompt"
}

parse_metadata_json() {
    python3 -c "$(cat << 'PY'
import json
import sys
import re

raw = sys.stdin.read()
def load_json(payload: str):
    try:
        return json.loads(payload)
    except Exception:
        return None

data = load_json(raw)
if data is None:
    fenced = re.search(r"```(?:json)?\\s*([\\s\\S]*?)```", raw)
    if fenced:
        data = load_json(fenced.group(1))
if data is None:
    for match in re.findall(r"{[\\s\\S]*?}", raw):
        data = load_json(match)
        if data is not None:
            break
if data is None:
    print("|||")
    sys.exit(0)

cat = str(data.get("category") or "").strip()
storage = str(data.get("storage_area") or "").strip()
project = str(data.get("project") or "").strip()
cp = str(data.get("counterparty") or "").strip()
print("|".join([cat, storage, project, cp]))
PY
)"
}

extract_transcript_excerpt() {
    local transcript="$1"
    local head
    local tail
    head=$(printf '%s' "$transcript" | head -c 6000)
    tail=$(printf '%s' "$transcript" | tail -c 6000)
    if [ "$head" = "$tail" ]; then
        printf '%s' "$head"
        return 0
    fi
    printf '%s\n\n----\n\n%s' "$head" "$tail"
}

format_bullets_inline() {
    local text="$1"
    local line
    local result=""
    while IFS= read -r line; do
        line="$(trim_text "$line")"
        line="$(printf '%s' "$line" | sed -E 's/^- \\[ \\] //; s/^[-*][[:space:]]+//')"
        [ -z "$line" ] && continue
        if [ -z "$result" ]; then
            result="$line"
        else
            result+=" / $line"
        fi
    done <<< "$text"
    printf '%s' "$result"
}

build_tags() {
    local category="$1"
    local storage_area="$2"
    local regular_tag="$3"

    local tag="#${category:-æœªåˆ†é¡}"
    if [ "$category" = "å•†è«‡" ]; then
        tag="#å•†è«‡ #é¡§å®¢å"
    elif [ "$category" = "ç¤¾å†…" ]; then
        tag="#ç¤¾å†… #å®šä¾‹"
    elif [ "$category" = "ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆ" ]; then
        tag="#ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆ"
    fi

    if [ -n "$regular_tag" ]; then
        if [[ "$tag" != *"#å®šä¾‹"* ]]; then
            tag="$tag #å®šä¾‹"
        fi
        tag="$tag #å®šä¾‹_${regular_tag}"
    fi

    case "$storage_area" in
        side-business) tag="$tag #å€‹äººäº‹æ¥­" ;;
        activity) tag="$tag #è¡¨ç¾æ´»å‹•" ;;
        thoughts) tag="$tag #æ€æƒ³" ;;
        life) tag="$tag #æ—¥å¸¸" ;;
    esac

    printf '%s' "$tag"
}

write_meeting_md() {
    local md_file="$1"
    local title="$2"
    local date_display="$3"
    local category="$4"
    local summary="$5"
    local decisions="$6"
    local todos="$7"
    local transcript="$8"
    local tag="$9"

    cat > "$md_file" << EOF
# $title

## åŸºæœ¬æƒ…å ±
- **æ—¥ä»˜**: $date_display
- **ã‚«ãƒ†ã‚´ãƒª**: ${category:-æœªåˆ†é¡}
- **å‚åŠ è€…**:
- **ç›®çš„**:

## è¦ç‚¹ã‚µãƒãƒªãƒ¼
$summary

## æ±ºå®šäº‹é …
$decisions

## TODO
$todos

## æ–‡å­—èµ·ã“ã—å…¨æ–‡
$transcript

## ã‚¿ã‚°
$tag
EOF
}

process_transcript() {
    local transcript_file="$1"
    local meeting_name="$2"
    local category="$3"
    local storage_area="$4"
    local project_name="$5"
    local date_display="$6"
    local platform="$7"
    local skip_summary="$8"
    local output_override="$9"
    local replace_existing="${10}"

    local transcript_content
    transcript_content="$(cat "$transcript_file")"

    local cleaned_title
    cleaned_title="$(normalize_title "$meeting_name")"

    local excerpt
    excerpt="$(extract_transcript_excerpt "$transcript_content")"

    if [ "$MEETING_STORAGE_MODE" = "auto" ] && { [ -z "$category" ] || [ -z "$storage_area" ] || [ "$storage_area" = "auto" ]; }; then
        local meta_raw
        meta_raw="$(extract_metadata_json "$excerpt")"
        if [ -n "$meta_raw" ]; then
            local parsed
            parsed="$(printf '%s' "$meta_raw" | parse_metadata_json)"
            local inferred_category
            local inferred_storage
            local inferred_project
            local inferred_counterparty
            IFS='|' read -r inferred_category inferred_storage inferred_project inferred_counterparty <<< "$parsed"
            if [ -z "$category" ] && [ -n "$inferred_category" ] && [ "$inferred_category" != "ä¸æ˜" ]; then
                category="$inferred_category"
            fi
            if [ -z "$storage_area" ] || [ "$storage_area" = "auto" ]; then
                storage_area="$inferred_storage"
            fi
            if [ -z "$project_name" ]; then
                project_name="$inferred_project"
            fi
            if [ -z "$cleaned_title" ] && [ -n "$inferred_counterparty" ]; then
                cleaned_title="$inferred_counterparty"
            fi
        fi
    fi

    local regular_title
    local regular_tag
    regular_title="$(match_regular_meeting "$cleaned_title" || true)"
    if [ -n "$regular_title" ]; then
        cleaned_title="$regular_title"
        regular_tag="$(sanitize_filename "$regular_title")"
    fi

    if [ -z "$cleaned_title" ]; then
        cleaned_title="ç„¡é¡Œ"
    fi

    local summary_text=""
    local decisions_text=""
    local todos_text=""
    local title_hint=""
    local summary_generated="0"

    if [ "$skip_summary" != "1" ]; then
        if [ "${#transcript_content}" -ge "$SUMMARY_MIN_CHARS" ]; then
            local summary_raw=""
            if [ -n "${MEETING_SUMMARY_JSON_PATH:-}" ] && [ -f "$MEETING_SUMMARY_JSON_PATH" ]; then
                summary_raw="$(cat "$MEETING_SUMMARY_JSON_PATH")"
            else
                summary_raw="$(extract_summary_json "$excerpt")"
            fi
            if [ -n "$summary_raw" ]; then
                local parsed_summary
                parsed_summary="$(printf '%s' "$summary_raw" | parse_summary_json)"
                IFS=$'\x1f' read -r summary_text decisions_text todos_text title_hint <<< "$parsed_summary"
                summary_text="$(decode_summary_field "$summary_text")"
                decisions_text="$(decode_summary_field "$decisions_text")"
                todos_text="$(decode_summary_field "$todos_text")"
                title_hint="$(decode_summary_field "$title_hint")"
                if [ -n "$summary_text" ]; then
                    summary_generated="1"
                fi
            fi
        else
            log_message "INFO" "çŸ­æ–‡ã®ãŸã‚è¦ç´„ã‚’ã‚¹ã‚­ãƒƒãƒ—ã—ã¾ã—ãŸ"
        fi
    fi

    if [ -z "$summary_text" ]; then
        summary_text="- ï¼ˆè¦ç´„æœªç”Ÿæˆï¼‰"
    else
        summary_text=$(printf '%s' "$summary_text" | sed -E 's/^/- /')
    fi
    if [ -z "$decisions_text" ]; then
        decisions_text="- ï¼ˆæœªæŠ½å‡ºï¼‰"
    else
        decisions_text=$(printf '%s' "$decisions_text" | sed -E 's/^/- /')
    fi
    if [ -z "$todos_text" ]; then
        todos_text="- [ ] ï¼ˆæœªæŠ½å‡ºï¼‰"
    else
        todos_text=$(printf '%s' "$todos_text" | sed -E 's/^/- [ ] /')
    fi

    if [ -z "$cleaned_title" ] && [ -n "$title_hint" ]; then
        cleaned_title="$title_hint"
    fi

    local safe_title
    safe_title="$(sanitize_filename "$cleaned_title")"

    local date_compact
    date_compact="${date_display//-/}"

    local output_dir
    local output_file_override=""
    if [ -n "$output_override" ]; then
        output_dir="$(dirname "$output_override")"
        output_file_override="$output_override"
    else
        output_dir="$(resolve_output_dir "$category" "$storage_area" "$project_name")"
        if [ -n "$regular_title" ] && [ -n "$category" ] && [ -d "$MEETINGS_DIR/$category/$regular_title" ]; then
            output_dir="$MEETINGS_DIR/$category/$regular_title"
        fi
    fi
    mkdir -p "$output_dir"

    local base_name="${date_compact}_${safe_title}"
    local md_filename="${base_name}.md"
    if [ "$replace_existing" = "1" ] && [ -n "$output_file_override" ]; then
        md_filename="$(basename "$output_file_override")"
    else
        local suffix=2
        while [ -e "$output_dir/$md_filename" ]; do
            md_filename="${base_name}_${suffix}.md"
            suffix=$((suffix + 1))
        done
    fi

    local md_file="$output_dir/$md_filename"
    local tag
    tag="$(build_tags "$category" "$storage_area" "$regular_tag")"

    write_meeting_md "$md_file" "$cleaned_title" "$date_display" "$category" "$summary_text" "$decisions_text" "$todos_text" "$transcript_content" "$tag"

    echo -e "${GREEN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
    echo -e "${GREEN}  ä¼šè­°ãƒ¡ãƒ¢ã‚’ä½œæˆã—ã¾ã—ãŸ${NC}"
    echo -e "${GREEN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
    echo ""
    echo -e "  ä¿å­˜å…ˆ: ${BLUE}$md_file${NC}"
    echo ""

    local decisions_inline
    local todos_inline
    decisions_inline="$(format_bullets_inline "$decisions_text")"
    todos_inline="$(format_bullets_inline "$todos_text")"

    local summary_inline
    summary_inline="$(format_bullets_inline "$summary_text")"

    # ClaudeãŒè©³ç´°ãªè­°äº‹éŒ²é€šçŸ¥ã‚’é€ã‚‹ãŸã‚ã€ãƒ„ãƒ¼ãƒ«å´ã®é€šçŸ¥ã¯ç„¡åŠ¹åŒ–
    # send_complete_notification "$md_file" "$summary_inline" "$decisions_inline" "$todos_inline"

    SUMMARY_SUCCESS="$summary_generated"
    printf '%s' "$md_file"
}

start_recording() {
    local meeting_name="$1"
    shift
    local category=""
    local storage_area=""
    local project_name=""
    local web_mode=""
    local platform=""
    local hold_mode=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --å•†è«‡|--shoudan)
                category="å•†è«‡"
                storage_area="work"
                shift
                ;;
            --ç¤¾å†…|--shanai)
                category="ç¤¾å†…"
                storage_area="work"
                shift
                ;;
            --ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆ|--private)
                category="ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆ"
                storage_area="private"
                shift
                ;;
            --side-business)
                storage_area="side-business"
                project_name="$2"
                shift 2
                ;;
            --activity)
                storage_area="activity"
                shift
                ;;
            --thoughts)
                storage_area="thoughts"
                shift
                ;;
            --life)
                storage_area="life"
                shift
                ;;
            --auto)
                storage_area="auto"
                shift
                ;;
            --web|--WEB)
                web_mode="web"
                shift
                ;;
            --platform)
                platform="$2"
                shift 2
                ;;
            --hold)
                hold_mode="1"
                shift
                ;;
            --no-hold)
                hold_mode="0"
                shift
                ;;
            *)
                shift
                ;;
        esac
    done

    local effective_hold_mode
    effective_hold_mode="$(resolve_hold_mode "$hold_mode")"

    if [ -z "$meeting_name" ]; then
        echo -e "${RED}ã‚¨ãƒ©ãƒ¼: ä¼šè­°åã‚’æŒ‡å®šã—ã¦ãã ã•ã„${NC}"
        exit 1
    fi

    if [ -f "$PID_FILE" ]; then
        local old_pid
        old_pid=$(cat "$PID_FILE" 2>/dev/null || true)
        if is_process_running "$old_pid"; then
            if [ "$MEETING_AUTO_STOP" = "1" ]; then
                echo -e "${YELLOW}éŒ²éŸ³ä¸­ã®ãŸã‚åœæ­¢ã—ã¦ã‹ã‚‰é–‹å§‹ã—ã¾ã™...${NC}"
                stop_recording "--async" || true
            else
                echo -e "${RED}ã‚¨ãƒ©ãƒ¼: æ—¢ã«éŒ²éŸ³ä¸­ã§ã™${NC}"
                echo "åœæ­¢ã™ã‚‹ã«ã¯: meeting stop"
                exit 1
            fi
        else
            echo -e "${YELLOW}è­¦å‘Š: å‰å›éŒ²éŸ³ã®çŠ¶æ…‹ãƒ•ã‚¡ã‚¤ãƒ«ãŒæ®‹ã£ã¦ã„ãŸãŸã‚ã‚¯ãƒªã‚¢ã—ã¾ã—ãŸ${NC}"
            log_message "WARN" "stale recording state cleared: pid=${old_pid:-empty}"
            cleanup_recording_state
        fi
    fi

    check_dependencies

    local date_str
    date_str=$(date +"%Y-%m-%d_%H%M%S")
    local clean_name
    clean_name="$(strip_date_prefix "$meeting_name")"
    clean_name="$(normalize_title "$clean_name")"
    if [ -z "$clean_name" ]; then
        clean_name="$meeting_name"
    fi
    local safe_name
    safe_name="$(sanitize_filename "$clean_name")"
    local filename="${date_str}_${safe_name}"
    local audio_file="$AUDIO_DIR/${filename}.wav"
    local ffmpeg_log_file="$AUDIO_DIR/${filename}.ffmpeg.log"

    echo ""
    echo -e "${GREEN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
    echo -e "${GREEN}  éŒ²éŸ³ã‚’é–‹å§‹ã—ã¾ã™${NC}"
    echo -e "${GREEN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
    echo ""
    echo -e "  ä¼šè­°å:   ${BLUE}$meeting_name${NC}"
    echo -e "  ã‚«ãƒ†ã‚´ãƒª: ${BLUE}${category:-æœªåˆ†é¡}${NC}"
    echo -e "  ãƒ¢ãƒ¼ãƒ‰:   ${BLUE}$([ -n "$web_mode" ] && echo "WEBä¼šè­°" || echo "å¯¾é¢ä¼šè­°")${NC}"
    echo ""

    if [ -n "$web_mode" ]; then
        warn_multisoundchanger
        switch_to_meeting_output
        sync_multisoundchanger
    fi

    local avfoundation_devices
    avfoundation_devices="$(list_avfoundation_audio_devices)"
    if [ -z "$avfoundation_devices" ]; then
        echo -e "${RED}ã‚¨ãƒ©ãƒ¼: AVFoundationã®éŸ³å£°ãƒ‡ãƒã‚¤ã‚¹ä¸€è¦§ã‚’å–å¾—ã§ãã¾ã›ã‚“ã§ã—ãŸ${NC}"
        echo "ã‚¿ãƒ¼ãƒŸãƒŠãƒ«ã®ãƒã‚¤ã‚¯æ¨©é™ç¢ºèªå¾Œã«å†å®Ÿè¡Œã—ã¦ãã ã•ã„"
        echo "ç¢ºèªã‚³ãƒãƒ³ãƒ‰: ffmpeg -f avfoundation -list_devices true -i \"\""
        if [ -n "$web_mode" ]; then
            restore_audio_output
        fi
        exit 1
    fi

    if [ -n "$web_mode" ]; then
        if ! audio_device_exists "$MEETING_WEB_INPUT_DEVICE"; then
            echo -e "${YELLOW}è­¦å‘Š: BlackHoleãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ï¼ˆç›¸æ‰‹ã®éŸ³å£°ãŒéŒ²éŸ³ã•ã‚Œãªã„å¯èƒ½æ€§ï¼‰${NC}"
            echo "ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«: brew install blackhole-2ch"
        fi

        local blackhole_device
        blackhole_device="$MEETING_WEB_INPUT_DEVICE"
        local mic_device
        mic_device="$(resolve_input_device_name)"

        local blackhole_index
        blackhole_index="$(resolve_avfoundation_index "$blackhole_device" "$avfoundation_devices" || true)"
        local mic_index
        mic_index="$(resolve_avfoundation_index "$mic_device" "$avfoundation_devices" || true)"

        if [ -n "$blackhole_index" ] && [ -n "$mic_index" ] && [ "$blackhole_index" != "$mic_index" ]; then
            local filter="[0:a]volume=${MEETING_WEB_INPUT_GAIN_BLACKHOLE}[bh];[1:a]volume=${MEETING_WEB_INPUT_GAIN_MIC}[mic];[bh][mic]amix=inputs=2:duration=longest:dropout_transition=2[mix]"
            if [ "$MEETING_WEB_LIMITER" = "1" ]; then
                filter+=";[mix]${MEETING_WEB_LIMITER_FILTER}[out]"
            else
                filter+=";[mix]anull[out]"
            fi

            echo -e "  å…¥åŠ›: ${BLUE}$mic_device${NC} + ${BLUE}$blackhole_device${NC}"
            : > "$ffmpeg_log_file"
            ffmpeg -y -f avfoundation -i ":$blackhole_index" -f avfoundation -i ":$mic_index" \
                -filter_complex "$filter" -map "[out]" -acodec pcm_s16le -ar 16000 "$audio_file" \
                >/dev/null 2>>"$ffmpeg_log_file" &
        else
            local target_index
            target_index="$mic_index"
            if [ -n "$blackhole_index" ]; then
                target_index="$blackhole_index"
                echo -e "  å…¥åŠ›: ${BLUE}$blackhole_device${NC}"
            else
                echo -e "  å…¥åŠ›: ${BLUE}${mic_device:-æ—¢å®šå…¥åŠ›}${NC}"
            fi
            if [ -z "$target_index" ]; then
                target_index="$(first_avfoundation_audio_index "$avfoundation_devices" || true)"
                if [ -n "$target_index" ]; then
                    echo -e "${YELLOW}è­¦å‘Š: å…¥åŠ›ãƒ‡ãƒã‚¤ã‚¹åã‚’è§£æ±ºã§ããªã„ãŸã‚å…ˆé ­ãƒ‡ãƒã‚¤ã‚¹(index:${target_index})ã‚’ä½¿ç”¨ã—ã¾ã™${NC}"
                fi
            fi
            if [ -z "$target_index" ]; then
                echo -e "${RED}ã‚¨ãƒ©ãƒ¼: æœ‰åŠ¹ãªéŸ³å£°å…¥åŠ›ãƒ‡ãƒã‚¤ã‚¹ã‚’è§£æ±ºã§ãã¾ã›ã‚“ã§ã—ãŸ${NC}"
                restore_audio_output
                exit 1
            fi
            : > "$ffmpeg_log_file"
            ffmpeg -y -f avfoundation -i ":$target_index" -acodec pcm_s16le -ar 16000 -flush_packets 1 "$audio_file" >/dev/null 2>>"$ffmpeg_log_file" &
        fi
    else
        local mic_device
        mic_device="$(get_default_audio_device)"
        local mic_index
        mic_index="$(resolve_avfoundation_index "$mic_device" "$avfoundation_devices" || true)"
        if [ -z "$mic_index" ]; then
            mic_index="$(first_avfoundation_audio_index "$avfoundation_devices" || true)"
            if [ -n "$mic_index" ]; then
                echo -e "${YELLOW}è­¦å‘Š: æ—¢å®šå…¥åŠ›ã‚’è§£æ±ºã§ããªã„ãŸã‚å…ˆé ­ãƒ‡ãƒã‚¤ã‚¹(index:${mic_index})ã‚’ä½¿ç”¨ã—ã¾ã™${NC}"
            fi
        fi
        if [ -z "$mic_index" ]; then
            echo -e "${RED}ã‚¨ãƒ©ãƒ¼: æœ‰åŠ¹ãªéŸ³å£°å…¥åŠ›ãƒ‡ãƒã‚¤ã‚¹ã‚’è§£æ±ºã§ãã¾ã›ã‚“ã§ã—ãŸ${NC}"
            exit 1
        fi
        : > "$ffmpeg_log_file"
        ffmpeg -y -f avfoundation -i ":$mic_index" -acodec pcm_s16le -ar 16000 -flush_packets 1 "$audio_file" >/dev/null 2>>"$ffmpeg_log_file" &
    fi

    local pid=$!
    local start_epoch
    start_epoch=$(date +%s)

    echo "$pid" > "$PID_FILE"
    echo "${filename}|${meeting_name}|${category}|${storage_area}|${project_name}|${platform}|${web_mode}|${start_epoch}|${ffmpeg_log_file}" > "$INFO_FILE"

    if is_process_running "$pid"; then
        if ! wait_for_recording_data "$pid" "$audio_file" "$([ -n "$web_mode" ] && echo web)"; then
            stop_recording_process "$pid"
            cleanup_recording_state
            if [ -n "$web_mode" ]; then
                restore_audio_output
            fi
            local bytes
            bytes="$(get_file_size_bytes "$audio_file")"
            if [ "$bytes" -eq 0 ]; then
                rm -f "$audio_file" 2>/dev/null || true
            fi
            echo -e "${RED}ã‚¨ãƒ©ãƒ¼: éŒ²éŸ³ã‚¹ãƒˆãƒªãƒ¼ãƒ ãŒå®‰å®šã›ãšé–‹å§‹ã«å¤±æ•—ã—ã¾ã—ãŸ${NC}"
            echo -e "${YELLOW}å…¥åŠ›ãƒ‡ãƒã‚¤ã‚¹/ãƒã‚¤ã‚¯æ¨©é™ã‚’ç¢ºèªã—ã¦å†å®Ÿè¡Œã—ã¦ãã ã•ã„${NC}"
            log_message "ERROR" "recording health check failed: ${meeting_name} (bytes=${bytes})"
            show_ffmpeg_log_tail "$ffmpeg_log_file"
            exit 1
        fi
        echo -e "${GREEN}  éŒ²éŸ³ä¸­... ğŸ™ï¸${NC}"
        echo ""
        echo "  åœæ­¢ã™ã‚‹ã«ã¯: meeting stop"
        echo ""
        log_message "INFO" "recording started: ${meeting_name}"
        local env_label
        env_label="$(resolve_env_label "$web_mode" "$platform")"
        send_start_notification "$meeting_name" "$env_label"
        if [ "$effective_hold_mode" = "1" ]; then
            echo "  --hold ãƒ¢ãƒ¼ãƒ‰ã§å¾…æ©Ÿä¸­ï¼ˆçµ‚äº†ã¯ meeting stopï¼‰"
            while [ -f "$PID_FILE" ]; do
                sleep 1
            done
        fi
    else
        echo -e "${RED}ã‚¨ãƒ©ãƒ¼: éŒ²éŸ³ã®é–‹å§‹ã«å¤±æ•—ã—ã¾ã—ãŸ${NC}"
        cleanup_recording_state
        if [ -n "$web_mode" ]; then
            restore_audio_output
        fi
        if [ "$(get_file_size_bytes "$audio_file")" -eq 0 ]; then
            rm -f "$audio_file" 2>/dev/null || true
        fi
        log_message "ERROR" "recording start failed: ${meeting_name}"
        show_ffmpeg_log_tail "$ffmpeg_log_file"
        exit 1
    fi
}

stop_recording() {
    local async="0"
    if [ "$1" = "--async" ]; then
        async="1"
    fi

    if [ ! -f "$PID_FILE" ]; then
        echo -e "${RED}ã‚¨ãƒ©ãƒ¼: éŒ²éŸ³ä¸­ã®ã‚»ãƒƒã‚·ãƒ§ãƒ³ãŒã‚ã‚Šã¾ã›ã‚“${NC}"
        exit 1
    fi

    local pid
    pid=$(cat "$PID_FILE" 2>/dev/null || true)
    local info
    info=$(cat "$INFO_FILE" 2>/dev/null || true)

    local filename=""
    local meeting_name=""
    local category=""
    local storage_area=""
    local project_name=""
    local platform=""
    local web_mode=""
    local start_epoch=""
    local ffmpeg_log_file=""

    IFS='|' read -r filename meeting_name category storage_area project_name platform web_mode start_epoch ffmpeg_log_file <<< "$info"
    if [ -z "$filename" ]; then
        echo -e "${RED}ã‚¨ãƒ©ãƒ¼: éŒ²éŸ³çŠ¶æ…‹ãŒå£Šã‚Œã¦ã„ã¾ã™ï¼ˆãƒ•ã‚¡ã‚¤ãƒ«åãŒç©ºï¼‰${NC}"
        log_message "ERROR" "invalid recording info: $INFO_FILE"
        cleanup_recording_state
        return 1
    fi

    local audio_file="$AUDIO_DIR/${filename}.wav"
    if [ -z "$ffmpeg_log_file" ] && [ -n "$filename" ]; then
        ffmpeg_log_file="$AUDIO_DIR/${filename}.ffmpeg.log"
    fi

    echo ""
    echo -e "${YELLOW}éŒ²éŸ³ã‚’åœæ­¢ã—ã¦ã„ã¾ã™...${NC}"

    if is_process_running "$pid"; then
        stop_recording_process "$pid"
    else
        echo -e "${YELLOW}è­¦å‘Š: éŒ²éŸ³ãƒ—ãƒ­ã‚»ã‚¹ã¯æ—¢ã«çµ‚äº†ã—ã¦ã„ã¾ã—ãŸ${NC}"
        log_message "WARN" "recording process already stopped: pid=${pid:-empty}"
    fi

    cleanup_recording_state

    local end_epoch
    end_epoch=$(date +%s)

    if [ -n "$web_mode" ]; then
        restore_audio_output
        sync_multisoundchanger
    fi

    if [ ! -f "$audio_file" ]; then
        echo -e "${RED}ã‚¨ãƒ©ãƒ¼: éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“${NC}"
        exit 1
    fi

    local file_size_bytes
    file_size_bytes="$(get_file_size_bytes "$audio_file")"
    if [ "$file_size_bytes" -le 0 ]; then
        echo -e "${RED}ã‚¨ãƒ©ãƒ¼: éŒ²éŸ³ãƒ‡ãƒ¼ã‚¿ãŒç©º(0B)ã§ã™ã€‚æ–‡å­—èµ·ã“ã—ã‚’ä¸­æ­¢ã—ã¾ã—ãŸ${NC}"
        echo -e "${YELLOW}å…¥åŠ›ãƒ‡ãƒã‚¤ã‚¹/ãƒã‚¤ã‚¯æ¨©é™ã‚’ç¢ºèªã—ã¦å†åº¦éŒ²éŸ³ã—ã¦ãã ã•ã„${NC}"
        log_message "ERROR" "empty recording detected: $audio_file"
        show_ffmpeg_log_tail "$ffmpeg_log_file"
        rm -f "$audio_file" 2>/dev/null || true
        return 1
    fi

    if [ -n "$start_epoch" ]; then
        local duration
        local diff
        diff=$((end_epoch - start_epoch))
        duration=$(printf '%dm%02ds' $((diff / 60)) $((diff % 60)))
        send_stop_notification "$duration"
    fi

    local file_size
    file_size=$(ls -lh "$audio_file" | awk '{print $5}')
    echo -e "${GREEN}éŒ²éŸ³å®Œäº†${NC} (ã‚µã‚¤ã‚º: $file_size)"
    echo ""

    if [ "$async" = "1" ]; then
        (process_recording "$audio_file" "$filename" "$meeting_name" "$category" "$storage_area" "$project_name" "$platform") &
        echo -e "${GREEN}ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã§å‡¦ç†ä¸­ã§ã™${NC}"
        return 0
    fi

    process_recording "$audio_file" "$filename" "$meeting_name" "$category" "$storage_area" "$project_name" "$platform"
}

process_recording() {
    local audio_file="$1"
    local filename="$2"
    local meeting_name="$3"
    local category="$4"
    local storage_area="$5"
    local project_name="$6"
    local platform="$7"

    local audio_size_bytes
    audio_size_bytes="$(get_file_size_bytes "$audio_file")"
    if [ "$audio_size_bytes" -le 0 ]; then
        echo -e "${RED}æ–‡å­—èµ·ã“ã—ã«å¤±æ•—ã—ã¾ã—ãŸï¼ˆéŸ³å£°ãƒ‡ãƒ¼ã‚¿ãŒç©ºã§ã™ï¼‰${NC}"
        log_message "ERROR" "transcription skipped due to empty audio: $audio_file"
        return 1
    fi

    echo -e "${YELLOW}æ–‡å­—èµ·ã“ã—ã‚’é–‹å§‹ã—ã¾ã™...${NC}"
    echo "ï¼ˆåˆå›ã¯æ•°åˆ†ã‹ã‹ã‚‹å ´åˆãŒã‚ã‚Šã¾ã™ - ãƒ¢ãƒ‡ãƒ«ã®ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã®ãŸã‚ï¼‰"
    echo ""

    if ! run_whisper "$audio_file" "$AUDIO_DIR"; then
        echo -e "${RED}æ–‡å­—èµ·ã“ã—ã«å¤±æ•—ã—ã¾ã—ãŸ${NC}"
        log_message "ERROR" "transcription failed: $audio_file"
        return 1
    fi

    local transcript_file="$AUDIO_DIR/${filename}.txt"
    if [ ! -f "$transcript_file" ]; then
        echo -e "${RED}æ–‡å­—èµ·ã“ã—ã«å¤±æ•—ã—ã¾ã—ãŸ${NC}"
        log_message "ERROR" "transcript missing: $transcript_file"
        return 1
    fi

    echo -e "${GREEN}æ–‡å­—èµ·ã“ã—å®Œäº†${NC}"

    # è­°äº‹éŒ²ä½œæˆã¯Claudeã«ä»»ã›ã‚‹ãŸã‚ã€æ–‡å­—èµ·ã“ã—ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹ã‚’è¡¨ç¤ºã—ã¦çµ‚äº†
    echo ""
    echo -e "${GREEN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
    echo -e "${GREEN}  æ–‡å­—èµ·ã“ã—ãŒå®Œäº†ã—ã¾ã—ãŸ${NC}"
    echo -e "${GREEN}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
    echo ""
    echo -e "  ä¼šè­°å: ${BLUE}$meeting_name${NC}"
    echo -e "  ã‚«ãƒ†ã‚´ãƒª: ${BLUE}${category:-æœªåˆ†é¡}${NC}"
    echo -e "  æ–‡å­—èµ·ã“ã—: ${BLUE}$transcript_file${NC}"
    echo ""

    log_message "INFO" "transcript completed: $transcript_file"

    # éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«ã®å‰Šé™¤
    if [ "$KEEP_AUDIO" != "1" ]; then
        rm -f "$audio_file" 2>/dev/null || true
    fi
}

list_recordings() {
    echo ""
    echo "===== ä¼šè­°ãƒ¡ãƒ¢ä¸€è¦§ ====="
    echo ""

    for section in "å•†è«‡" "ç¤¾å†…" "private"; do
        echo -e "${BLUE}ã€${section}ã€‘${NC}"
        if ls "$MEETINGS_DIR/$section"/*.md 2>/dev/null | head -1 > /dev/null; then
            ls -lt "$MEETINGS_DIR/$section"/*.md 2>/dev/null | head -10 | while read -r line; do
                local file
                file=$(echo "$line" | awk '{print $NF}')
                local basename
                basename=$(basename "$file")
                echo "  - $basename"
            done
        else
            echo "  (ãªã—)"
        fi
        echo ""
    done
}

reprocess_transcript() {
    local transcript="$1"
    shift

    local md_path=""
    local replace="0"
    local date_override=""
    local title_override=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --md)
                md_path="$2"
                shift 2
                ;;
            --replace)
                replace="1"
                shift
                ;;
            --date)
                date_override="$2"
                shift 2
                ;;
            --title)
                title_override="$2"
                shift 2
                ;;
            *)
                shift
                ;;
        esac
    done

    if [ ! -f "$transcript" ]; then
        echo -e "${RED}ã‚¨ãƒ©ãƒ¼: transcript ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“${NC}"
        exit 1
    fi

    local meeting_name="$title_override"
    local date_display="$date_override"
    local output_override=""
    local category=""
    local storage_area="auto"
    local project_name=""

    if [ -n "$md_path" ] && [ -f "$md_path" ]; then
        output_override="$md_path"
        if [ -z "$meeting_name" ]; then
            meeting_name=$(head -n 1 "$md_path" | sed -E 's/^# //')
        fi
        if [ -z "$date_display" ]; then
            date_display=$(grep -m 1 "\*\*æ—¥ä»˜\*\*:" "$md_path" | sed -E 's/.*\*\*æ—¥ä»˜\*\*:[[:space:]]*//')
        fi
        if [ -z "$category" ]; then
            category=$(grep -m 1 "\*\*ã‚«ãƒ†ã‚´ãƒª\*\*:" "$md_path" | sed -E 's/.*\*\*ã‚«ãƒ†ã‚´ãƒª\*\*:[[:space:]]*//')
        fi
        if [[ "$md_path" == *"/side-business/"* ]]; then
            storage_area="side-business"
            project_name=$(printf '%s' "$md_path" | sed -E 's#.*/side-business/([^/]+)/.*#\\1#')
        elif [[ "$md_path" == *"/activities/"* ]]; then
            storage_area="activity"
        elif [[ "$md_path" == *"/thoughts/"* ]]; then
            storage_area="thoughts"
        elif [[ "$md_path" == *"/life/"* ]]; then
            storage_area="life"
        elif [[ "$md_path" == *"/private/"* ]]; then
            storage_area="private"
        fi
    fi

    if [ -n "$storage_area" ] && { [ -z "$category" ] || [ "$category" = "æœªåˆ†é¡" ]; }; then
        if [ "$storage_area" = "side-business" ]; then
            category="ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆ"
        fi
    fi

    if [ -z "$meeting_name" ]; then
        meeting_name="å†å‡¦ç†"
    fi
    if [ -z "$date_display" ]; then
        date_display="$(date +%Y-%m-%d)"
    fi

    process_transcript "$transcript" "$meeting_name" "$category" "$storage_area" "$project_name" "$date_display" "" "0" "$output_override" "$replace"
}

extract_transcript_from_memo() {
    local memo="$1"
    local in_section="0"
    while IFS= read -r line; do
        if printf '%s' "$line" | grep -q '^## æ–‡å­—èµ·ã“ã—å…¨æ–‡'; then
            in_section="1"
            continue
        fi
        if [ "$in_section" = "1" ]; then
            printf '%s\n' "$line"
        fi
    done < "$memo"
}

import_memo() {
    local memo="$1"
    shift

    local category=""
    local storage_area=""
    local project_name=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --å•†è«‡|--shoudan)
                category="å•†è«‡"
                storage_area="work"
                shift
                ;;
            --ç¤¾å†…|--shanai)
                category="ç¤¾å†…"
                storage_area="work"
                shift
                ;;
            --ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆ|--private)
                category="ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆ"
                storage_area="private"
                shift
                ;;
            --side-business)
                storage_area="side-business"
                project_name="$2"
                shift 2
                ;;
            --activity)
                storage_area="activity"
                shift
                ;;
            --thoughts)
                storage_area="thoughts"
                shift
                ;;
            --life)
                storage_area="life"
                shift
                ;;
            *)
                shift
                ;;
        esac
    done

    if [ ! -f "$memo" ]; then
        echo -e "${RED}ã‚¨ãƒ©ãƒ¼: ãƒ¡ãƒ¢ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“${NC}"
        exit 1
    fi

    local transcript
    transcript="$(extract_transcript_from_memo "$memo")"
    if [ -z "$transcript" ]; then
        transcript="$(cat "$memo")"
    fi

    local timestamp
    timestamp=$(date +"%Y-%m-%d_%H%M%S")
    local transcript_file="$AUDIO_DIR/import_${timestamp}.txt"
    printf '%s\n' "$transcript" > "$transcript_file"

    local date_display
    date_display="$(date +%Y-%m-%d)"
    local meeting_name
    meeting_name="$(head -n 1 "$memo" | sed -E 's/^# //')"
    if [ -z "$meeting_name" ]; then
        meeting_name="ãƒ¡ãƒ¢å–ã‚Šè¾¼ã¿"
    fi

    local skip_summary="1"
    if [ "${MEETING_IMPORT_SUMMARY:-0}" = "1" ]; then
        skip_summary="0"
    fi

    local md_path
    md_path="$(process_transcript "$transcript_file" "$meeting_name" "$category" "$storage_area" "$project_name" "$date_display" "" "$skip_summary" "" "0")"

    if [ -n "$md_path" ]; then
        local target_dir
        target_dir="$(dirname "$md_path")"
        local memo_base
        memo_base=$(basename "$memo")
        local target_path="$target_dir/$memo_base"
        if [ -e "$target_path" ]; then
            local suffix=2
            local base_name
            base_name="${memo_base%.*}"
            local ext="${memo_base##*.}"
            while [ -e "$target_dir/${base_name}_${suffix}.${ext}" ]; do
                suffix=$((suffix + 1))
            done
            target_path="$target_dir/${base_name}_${suffix}.${ext}"
        fi
        mv "$memo" "$target_path"
    fi
}

ensure_dirs
rotate_logs

case "$1" in
    start)
        shift
        start_recording "$@"
        ;;
    stop)
        shift
        stop_recording "$@"
        ;;
    list)
        list_recordings
        ;;
    reprocess)
        shift
        reprocess_transcript "$@"
        ;;
    import)
        shift
        import_memo "$@"
        ;;
    help|--help|-h|"")
        show_help
        ;;
    *)
        show_help
        exit 1
        ;;
esac
